Реализовано:
Хранение и передача коэффициентов и степеней по описанному Леной алгоритму.

Сразу извиняюсь за местами кривой код и названия переменных. Не было времени обращать на это слишком много внимания. Я потом по красоте все сделаю.

Как это реализовано:

Теперь хранятся только ненулевые коэффициенты. Я решил сделать следующим образом.

Теперь есть две структуры: для кубического многочлена (CubePolynomial) и для многочлена из открытого ключа (FullCubePolynomial). Они практически идентичны. Отличаются только размером массивов. Каждая структура содержит два одномерных массива: ulong factor[] - массив коэффициентов и uint vars[] - массив индексов.

Элементы этих двух массивов связаны напрямую. 0-й индекс с 0-вым, 1-й - с 1-ым и так далее. В первом массиве просто по порядку все ненулевые коэффициенты. Во втором соответствующие слагаемому индексы иксов. То есть для двух переменных и слагаемого 4*x1*x1*x2 в первом массиве будет лежать число 4, а во втором 010111000...000 (в битовом представлении), где первые 2*3 = 6 бит означают индексы. Остальные нули незначащие. Сейчас этот массив uint (32 бита). Это значит, что мы можем его использовать для 2^10 - 1 = 1023 переменных. При необходимости его можно заменить на массив ulong. Тогда кол-во переменных будет 2^21-1.

Когда вы будете реализовывать фиксированные переменные, просто в массиве индексов индекс соответствующего ИКСА замените на 0. При шифровании это учтется, как умножение на 1. Это не точно, потому что я не мог это протестировать по понятным причинам. Но по идее все должно работать. Вообще, насколько я понял, вам transmitter не нужен будет для фиксированных переменных.

Для работы с массивом индексов понадобятся две функции: writeToVar() - запись индекса в число на определенную позицию и getFromVar() - считывание индекса из числа с определенной позиции. Они описаны в computePublicKey.c (в transmitter они в main.c).

Сами открытый ключ и массив кубических многочленов теперь массивы выше указанных структур.

Открытый ключ я передаю предельно просто. Просто в файл записываю массив структур, а потом считываю.

Всякие заметки:

Все это еще потребует оптимизации. Но все же сейчас все достаточно хорошо и быстро работает.

Отмечу, что кол-во переменных обязательно должно быть кратно числу переменных в строке. Это в принципе по алгоритму построения первой матрицы должно быть. Я проверок не вставлял, так что программа либо сломается, либо будет работать неправильно.

Толя, убери динамику.

Используйте ulong. Другие типы только там, где вы точно уверены, что не может быть переполнения. Но лучше не рискуйте.

Обратите внимание, что у нас модульная арифметика разделена на две части: ту, которая работает только с нашим основным модулем, и ту, которая работает с произвольным. Это сделано для того, чтобы облегчить код.

Толя, твои функции генерации матрицы внизу в файле generateSecretKey.c.

Буду очень рад, если будете соблюдать мой стиль написания кода, чтобы весь проект был в одном стиле.

Функции вывода массивов структур внизу в main.c.